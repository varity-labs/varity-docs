# Varity - Build, Deploy, and Monetize Apps

> Varity provides open-source packages and a CLI for developers to build, deploy, and monetize applications. 70-85% cheaper than AWS. Zero configuration required for deployment.

## Packages

- `@varity-labs/sdk` — Core SDK. Database module: `import { db } from '@varity-labs/sdk'`
- `@varity-labs/ui-kit` — React components: PrivyStack, PrivyLoginButton, PrivyProtectedRoute, PrivyUserProfile, DashboardLayout, usePrivy
- `@varity-labs/types` — TypeScript type definitions
- `varitykit` (CLI) — Python CLI: `pip install varitykit`

## Database API

```typescript
import { db } from '@varity-labs/sdk';

// Typed collection
const users = db.collection<User>('users');

// CRUD operations
await users.add({ name: 'John', email: 'john@example.com' });  // Insert
await users.get();                                               // Get all
await users.get({ limit: 10, offset: 0, orderBy: '-createdAt' }); // Paginated + sorted
await users.update('doc-id', { name: 'Jane' });                 // Update by ID
await users.delete('doc-id');                                    // Delete by ID

// Filtering: done client-side
const all = await users.get();
const active = all.filter(u => u.status === 'active');
```

### .get() options
- `limit` — Max documents to return
- `offset` — Skip N documents (pagination)
- `orderBy` — Field name ("field" ascending, "-field" descending)
- NOTE: No server-side filtering. Filter results on the client.

### How it works under the hood
- SDK makes HTTP requests to a database proxy service
- CLI auto-generates JWT credentials at deploy time
- Data stored in PostgreSQL (via Supabase) with per-app schema isolation
- For local dev, set env vars manually or build UI with mock data first

## Authentication

```tsx
import { PrivyStack, PrivyLoginButton, PrivyProtectedRoute, usePrivy } from '@varity-labs/ui-kit';

// Wrap app root
<PrivyStack appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID}>
  <App />
</PrivyStack>

// Login button (email, Google, Twitter, Discord, GitHub)
<PrivyLoginButton />

// Protected content
<PrivyProtectedRoute>
  <Dashboard />
</PrivyProtectedRoute>

// Access user
const { user, authenticated, logout } = usePrivy();
const email = user?.email?.address;
```

## CLI Commands

```bash
varitykit doctor              # Check environment
varitykit init my-app         # Scaffold from SaaS template
varitykit app deploy          # Deploy (auto-detects static/dynamic)
varitykit app deploy --submit-to-store  # Deploy + submit to App Store
```

## Key Patterns

### Database: Type -> Collection -> Hook -> Page

1. Define TypeScript interface in `src/types/index.ts`
2. Create collection: `export const items = () => db.collection<Item>('items')`
3. Build React hook with useState/useEffect/useCallback for CRUD + optimistic updates
4. Use hook in page component

### Credential Injection (at deploy time)

The CLI generates: app_id, JWT token, db_proxy_url
These are written to .env.local, compiled into the build, then .env.local is deleted.
Environment variables: NEXT_PUBLIC_VARITY_APP_ID, NEXT_PUBLIC_VARITY_APP_TOKEN, NEXT_PUBLIC_VARITY_DB_PROXY_URL

### Revenue Model

90% to developer, 10% to Varity platform. Set pricing in Developer Portal after deploying.

## Documentation

- Getting Started: https://docs.varity.so/getting-started/quickstart
- Database: https://docs.varity.so/build/databases/quickstart
- Authentication: https://docs.varity.so/build/auth/quickstart
- Templates: https://docs.varity.so/templates/saas-starter
- CLI: https://docs.varity.so/cli/overview
- Deploy: https://docs.varity.so/deploy/varity-l3

## Important Rules

- NEVER use blockchain/crypto terminology in user-facing content
- Use "deploy" not "upload to IPFS"
- Use "sign in" not "connect wallet"
- Use "usage fees are covered" not "gasless transactions"
- Static export: Use `output: 'export'` in next.config.js
- No dynamic routes ([id]) with static export — use client-side state
